Timer unit: 1e-06 s

Total time: 6.50847 s
File: pointtrace.py
Function: generate_splat at line 31

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    31                                           @profile
    32                                           def generate_splat(pcd, pcd_tree, point, k, threshold, perc, points, activated):
    33     59999    1527110.0     25.5     23.5      [k, idx, _] = pcd_tree.search_knn_vector_3d(point, k)
    34     59999     340711.0      5.7      5.2      found_points = points[idx]
    35     59999    2309034.0     38.5     35.5      normal = fitPLaneLTSQ(found_points)
    36     59999     166794.0      2.8      2.6      h = (found_points[0] - found_points).dot(normal)
    37     59999      84757.0      1.4      1.3      f = np.abs(h) < threshold
    38     59999     137448.0      2.3      2.1      v = np.where(f == 0)[0]
    39     59999      25408.0      0.4      0.4      if v.size == 0:
    40     59999      21762.0      0.4      0.3          ind = k - 1
    41     59999      20234.0      0.3      0.3          trueh = h
    42                                               else:
    43                                                   ind = v[0]
    44                                                   trueh = h[:ind]
    45                                           
    46     59999     569338.0      9.5      8.7      center = found_points[0] + normal * ((np.amax(trueh) - np.amin(trueh)) / 2)
    47    119998     388504.0      3.2      6.0      radius = np.linalg.norm(
    48     59999     148253.0      2.5      2.3          (found_points[ind] - center) - normal.dot(found_points[ind] - center) * normal
    49                                               )
    50                                           
    51     59999     215322.0      3.6      3.3      [k, idx, _] = pcd_tree.search_radius_vector_3d(point, radius * perc)
    52                                               #np.asarray(pcd.colors)[idx, :] = [0, 1, 1]  # Convert all relevant points to blue.
    53     59999     358230.0      6.0      5.5      s = np.size(activated[idx]) - np.count_nonzero(activated[idx])
    54     59999     121392.0      2.0      1.9      activated[idx] = True
    55     59999      74171.0      1.2      1.1      return Splat(center, normal, radius, points)

Total time: 7.7453 s
File: pointtrace.py
Function: create_splats at line 58

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    58                                           @profile
    59                                           def create_splats(world, pcd, pcd_tree, k, threshold, perc, points):
    60         1         43.0     43.0      0.0      activated = np.full(len(points), False)
    61         1       1302.0   1302.0      0.0      available_indices = np.where(activated == 0)[0]
    62         1          0.0      0.0      0.0      i = 0
    63         1          0.0      0.0      0.0      c = 0
    64                                               while True:
    65     60000      21683.0      0.4      0.3          i += 1
    66     60000      21680.0      0.4      0.3          if i % 10000 == 0:
    67         6          5.0      0.8      0.0              c += 1
    68         6       2100.0    350.0      0.0              s = np.sum(activated)
    69         6        147.0     24.5      0.0              print("Points covered:", s, ", Splats:", i)
    70         6          6.0      1.0      0.0              if s > NUMBER_OF_POINTS:
    71         1          0.0      0.0      0.0                  break
    72                                           
    73     59999     510869.0      8.5      6.6          p = np.random.choice(available_indices)
    74    119998    7033266.0     58.6     90.8          c_splat = generate_splat(
    75     59999     115607.0      1.9      1.5              pcd, pcd_tree, pcd.points[p], k, threshold, perc, points, activated
    76                                                   )
    77     59999      38591.0      0.6      0.5          world.add_splat(c_splat)

Total time: 0.003522 s
File: pointtrace.py
Function: test_sink_hit at line 79

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    79                                           @profile
    80                                           def test_sink_hit(O, D, scene):
    81        24        692.0     28.8     19.6      rays = o3d.core.Tensor(np.hstack((O, D)),
    82        12         51.0      4.2      1.4                             dtype=o3d.core.Dtype.Float32)
    83        12       1469.0    122.4     41.7      ans = scene.cast_rays(rays)
    84        12         44.0      3.7      1.2      hits = ans['t_hit'].numpy()
    85        12        108.0      9.0      3.1      sink_indexes = np.where(hits != np.inf)[0]
    86        12         44.0      3.7      1.2      O_new = O[sink_indexes]
    87        12         15.0      1.2      0.4      D_new = D[sink_indexes]
    88        12          9.0      0.8      0.3      t = hits[sink_indexes]
    89        12          8.0      0.7      0.2      if(t.size > 0):
    90         6         31.0      5.2      0.9          H = O_new + D_new * t[:, None]
    91         6        894.0    149.0     25.4          return create_lineset(O_new, H, 100) #100 to cha
    92                                               else:
    93         6        157.0     26.2      4.5          return create_lineset(np.array([[0, 0, 0]]), np.array([[0, 0, 0]]), 0) #Fake lineset cuz im too lazy to add testing

Total time: 22.7019 s
File: pointtrace.py
Function: improved_ray_splat_intersection at line 95

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    95                                           @profile
    96                                           def improved_ray_splat_intersection(O, D, world, depth, scene):
    97        12         11.0      0.9      0.0      center = world.center
    98        12         11.0      0.9      0.0      normal = world.normal
    99        12          9.0      0.8      0.0      radius = world.radius
   100        12         11.0      0.9      0.0      radius_squared = world.radius_squared
   101                                           
   102        12       3675.0    306.2      0.0      hls = test_sink_hit(O, D, scene) # hit line set 
   103        12     640235.0  53352.9      2.8      denoms = normal.dot(D.T)
   104        12    6386798.0 532233.2     28.1      t = np.einsum("ijk, ik->ij", (center[:, None] - O), normal) / denoms
   105        12     668135.0  55677.9      2.9      t[t < 0] = np.inf
   106        12    2942264.0 245188.7     13.0      points = O + np.einsum("ij, jl->ijl", t, D)
   107        12    2705088.0 225424.0     11.9      distances = center[:, None] - points
   108        12    3775271.0 314605.9     16.6      distances_squared = np.sum(np.square(distances), axis=2)
   109        12     513150.0  42762.5      2.3      distances_squared[distances_squared > radius_squared[:, None]] = np.inf
   110        12     945868.0  78822.3      4.2      k = np.where(distances_squared != np.inf)
   111        12       2662.0    221.8      0.0      tk = t[k]
   112        12       1189.0     99.1      0.0      n = k[1].tolist()
   113        12         51.0      4.2      0.0      d = defaultdict(lambda: len(d))
   114        12      14479.0   1206.6      0.1      ids = np.array([d[x] for x in n])
   115        12          9.0      0.8      0.0      try:
   116        12        330.0     27.5      0.0          l = np.max(ids) + 1
   117                                               except:
   118                                                   return 1, 1, 1, 1, 1, 1
   119        12       7454.0    621.2      0.0      origin_distances = points[k] - O[k[1]]
   120        12        434.0     36.2      0.0      k = np.column_stack((k[1], k[0], ids))
   121        12        135.0     11.2      0.0      true_points = np.full((l, 3), np.inf)
   122        12         24.0      2.0      0.0      normals = np.zeros((l, 3))
   123        12         15.0      1.2      0.0      hits = np.zeros(l)
   124        12         18.0      1.5      0.0      inds = np.zeros(l, dtype=int)
   125    116163      81838.0      0.7      0.4      for i in range(len(k)):
   126    116151     131586.0      1.1      0.6          r, s, cid = k[i]
   127    116151     139357.0      1.2      0.6          current_distance = true_points[cid] - O[r]
   128    116151     204292.0      1.8      0.9          current_distance_squared = np.dot(current_distance, current_distance)
   129    116151      89198.0      0.8      0.4          new_distance = origin_distances[i]
   130    116151     199253.0      1.7      0.9          if np.dot(new_distance, new_distance) < current_distance_squared:
   131     14967      22887.0      1.5      0.1              true_points[cid] = origin_distances[i] + O[r]
   132     14967      16582.0      1.1      0.1              normals[cid] = normal[s]
   133     14967      12248.0      0.8      0.1              hits[cid] = tk[i]
   134     14967      11278.0      0.8      0.0              inds[cid] = r
   135        12      19580.0   1631.7      0.1      ls = create_lineset(O[inds], true_points, depth)
   136        12    3166197.0 263849.8     13.9      ns = create_lineset(center, center + normal, depth)
   137        12        299.0     24.9      0.0      return true_points, D[inds], normals, hits, ls, ns, hls

Total time: 23.6563 s
File: pointtrace.py
Function: cast_ray at line 160

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   160                                           @profile
   161                                           def cast_ray(world, O, D, depth, geometry, scene):
   162        18          9.0      0.5      0.0      if depth == 0:
   163         6          0.0      0.0      0.0          return geometry
   164        12   23636403.0 1969700.2     99.9      O, D, normals, t, line_set, normal_set, hit_line_set = improved_ray_splat_intersection(O, D, world, depth, scene)
   165        12         32.0      2.7      0.0      if type(O) == int:
   166                                                   return geometry
   167        12         13.0      1.1      0.0      geometry.append(line_set)
   168        12          6.0      0.5      0.0      geometry.append(hit_line_set)
   169                                               #geometry.append(normal_set)
   170        24        782.0     32.6      0.0      bad_normals = np.where(np.sum(D * normals, axis=1) > 0)[
   171        12          4.0      0.3      0.0          0
   172                                               ]  # If ray and normal are on same side(dot product > 0) make the normal negative
   173        12        163.0     13.6      0.0      normals[bad_normals] = -normals[bad_normals]
   174        12        262.0     21.8      0.0      reflected = D - 2 * np.sum(D * normals, axis=1)[:, None] * normals
   175                                               #O += reflected * M_FACTOR
   176        12      18543.0   1545.2      0.1      last_hit = create_lineset(O, O + reflected * 0.5, 100)
   177        12         33.0      2.8      0.0      cast_ray(world, O, reflected, depth - 1, geometry, scene)
   178        12          5.0      0.4      0.0      return last_hit

Total time: 34.2333 s
File: pointtrace.py
Function: main at line 195

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   195                                           @profile
   196                                           def main():
   197                                           
   198         1         40.0     40.0      0.0      np.random.seed(0)
   199         1         34.0     34.0      0.0      pcd2 = o3d.geometry.PointCloud()
   200         1          7.0      7.0      0.0      file_name = "pointclouds/car_cart4.mat"
   201         1     170656.0 170656.0      0.5      other_points = scipy.io.loadmat(file_name)['car_cart'] + [-10, 2, 5]
   202         1       7168.0   7168.0      0.0      end_points = other_points[np.random.choice(len(other_points), size=NUMBER_OF_RAYS, replace=False)]
   203                                           
   204         1     234904.0 234904.0      0.7      pcd2.points = o3d.utility.Vector3dVector(other_points)
   205                                           
   206                                           
   207         1         14.0     14.0      0.0      O = np.zeros(NUMBER_OF_RAYS * 3).reshape(NUMBER_OF_RAYS, 3)
   208         1          9.0      9.0      0.0      O.T[1] = 5
   209         1          2.0      2.0      0.0      O.T[2] = 8
   210         1         16.0     16.0      0.0      D = end_points - O
   211         1        104.0    104.0      0.0      D = D / np.linalg.norm(D, axis=1, keepdims=True)  # normalize directions
   212                                           
   213                                               '''
   214                                               D = -np.random.rand(NUMBER_OF_RAYS * 3).reshape(NUMBER_OF_RAYS, 3)
   215                                               D = D / np.linalg.norm(D, axis=1, keepdims=True)  # normalize directions
   216                                           
   217                                               O = np.zeros(3).reshape(1, 3)
   218                                               O.T[1] = 5
   219                                               O.T[2] = 10
   220                                               D = np.array([[-0.82650114, -0.3520768, -0.43924685]])
   221                                               '''
   222                                           
   223                                               '''
   224                                               file_name = "pointclouds/atk_back.pcd"
   225                                               pcd = o3d.io.read_point_cloud(file_name)
   226                                               points = np.asarray(pcd.points)
   227                                               points += np.random.normal(0, 0.000001, points.shape)
   228                                               points = np.vstack((points, other_points))
   229                                               pcd.points = o3d.utility.Vector3dVector(points)
   230                                           
   231                                               '''
   232         1          1.0      1.0      0.0      geometries = []
   233                                           
   234         1     255498.0 255498.0      0.7      pcd_tree = o3d.geometry.KDTreeFlann(pcd2)
   235                                           
   236         1         11.0     11.0      0.0      world = World()
   237                                           
   238         1        310.0    310.0      0.0      scene = add_sink(world, geometries)
   239         1    7875390.0 7875390.0     23.0      create_splats(world, pcd2, pcd_tree, 100, THRESHOLD, PERC, other_points)
   240         1      53469.0  53469.0      0.2      world.construct_world_splat()
   241         1          1.0      1.0      0.0      bs = 500
   242         7          8.0      1.1      0.0      for i in range(6):
   243         6        119.0     19.8      0.0          print(i)
   244         6   23657575.0 3942929.2     69.1          lh = cast_ray(world, O[(i * bs): ((i + 1) * bs)], D[(i * bs): ((i + 1) * bs)], 2, geometries, scene)
   245                                               #geometries.append(pcd)
   246         1          1.0      1.0      0.0      geometries.append(pcd2)
   247                                               #geometries.append(lh)
   248         1    1977857.0 1977857.0      5.8      o3d.visualization.draw_geometries(geometries)
   249                                           
   250                                           
   251                                               #PRINT HYPERPARAMETERS AND STATS:
   252         1         72.0     72.0      0.0      print("\n\nHyperparameters: ")
   253         1          8.0      8.0      0.0      print("_____________________________")
   254         1         17.0     17.0      0.0      print("Perc:", PERC)
   255         1          6.0      6.0      0.0      print("Threshold:", THRESHOLD)
   256         1          7.0      7.0      0.0      print("Number of points:", NUMBER_OF_POINTS)
   257         1          6.0      6.0      0.0      print("Number of rays:", NUMBER_OF_RAYS)
   258         1          5.0      5.0      0.0      print("Depth:", DEPTH)
   259         1          5.0      5.0      0.0      print("Splat Size", SPLAT_SIZE)
   260         1          6.0      6.0      0.0      print("\nOther stats:")
   261         1         10.0     10.0      0.0      print("Total splats generated: ", len(world.splats))

